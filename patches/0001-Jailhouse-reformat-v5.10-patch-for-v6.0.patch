From 5abe7d8e7d931f1e637ddc12fec8a8a93e494a01 Mon Sep 17 00:00:00 2001
From: Bill Mills <bill.mills@linaro.org>
Date: Wed, 8 Mar 2023 10:56:40 -0500
Subject: [PATCH] Jailhouse: reformat v5.10 patch for v6.0

Jailhouse requires kernel patches for the root cell.
The 5.10 patch is embedded in ci/gen-kernel-build.sh in Jailhouse.
The 5.10 patch is reworked here to apply to v6.0.

Signed-off-by: Bill Mills <bill.mills@linaro.org>
---
 arch/arm/include/asm/virt.h  |  5 +++++
 arch/arm/kernel/armksyms.c   |  5 +++++
 arch/arm/kernel/hyp-stub.S   | 41 +++++++++++++++++++++++++++++-------
 arch/arm64/kernel/hyp-stub.S |  2 ++
 arch/x86/kernel/apic/apic.c  |  1 +
 mm/vmalloc.c                 |  2 ++
 6 files changed, 48 insertions(+), 8 deletions(-)

diff --git a/arch/arm/include/asm/virt.h b/arch/arm/include/asm/virt.h
index dd9697b2bde8..47600a5894b1 100644
--- a/arch/arm/include/asm/virt.h
+++ b/arch/arm/include/asm/virt.h
@@ -39,6 +39,8 @@ static inline void sync_boot_mode(void)
 	sync_cache_r(&__boot_cpu_mode);
 }
 
+void __hyp_set_vectors(unsigned long phys_vector_base);
+void __hyp_reset_vectors(void);
 #else
 #define __boot_cpu_mode	(SVC_MODE)
 #define sync_boot_mode()
@@ -73,6 +75,9 @@ static inline bool is_kernel_in_hyp_mode(void)
 
 #define HVC_SET_VECTORS 0
 #define HVC_SOFT_RESTART 1
+#define HVC_RESET_VECTORS 2
+
+#define HVC_STUB_HCALL_NR 3
 
 #endif /* __ASSEMBLY__ */
 
diff --git a/arch/arm/kernel/armksyms.c b/arch/arm/kernel/armksyms.c
index 82e96ac83684..354ab3e4e41f 100644
--- a/arch/arm/kernel/armksyms.c
+++ b/arch/arm/kernel/armksyms.c
@@ -16,6 +16,7 @@
 
 #include <asm/checksum.h>
 #include <asm/ftrace.h>
+#include <asm/virt.h>
 
 /*
  * libgcc functions - functions that are used internally by the
@@ -175,3 +176,7 @@ EXPORT_SYMBOL(__pv_offset);
 EXPORT_SYMBOL(__arm_smccc_smc);
 EXPORT_SYMBOL(__arm_smccc_hvc);
 #endif
+
+#ifdef CONFIG_ARM_VIRT_EXT
+EXPORT_SYMBOL_GPL(__boot_cpu_mode);
+#endif
diff --git a/arch/arm/kernel/hyp-stub.S b/arch/arm/kernel/hyp-stub.S
index b699b22a4db1..b9ba0585a4ce 100644
--- a/arch/arm/kernel/hyp-stub.S
+++ b/arch/arm/kernel/hyp-stub.S
@@ -6,6 +6,7 @@
 #include <linux/init.h>
 #include <linux/irqchip/arm-gic-v3.h>
 #include <linux/linkage.h>
+#include <asm-generic/export.h>
 #include <asm/assembler.h>
 #include <asm/virt.h>
 
@@ -186,19 +187,19 @@ ARM_BE8(orr	r7, r7, #(1 << 25))     @ HSCTLR.EE
 ENDPROC(__hyp_stub_install_secondary)
 
 __hyp_stub_do_trap:
-#ifdef ZIMAGE
 	teq	r0, #HVC_SET_VECTORS
 	bne	1f
-	/* Only the ZIMAGE stubs can change the HYP vectors */
 	mcr	p15, 4, r1, c12, c0, 0	@ set HVBAR
 	b	__hyp_stub_exit
-#endif
 
 1:	teq	r0, #HVC_SOFT_RESTART
-	bne	2f
+	bne	1f
 	bx	r1
 
-2:	ldr	r0, =HVC_STUB_ERR
+1:	teq	r0, #HVC_RESET_VECTORS
+	beq	__hyp_stub_exit
+
+	ldr	r0, =HVC_STUB_ERR
 	__ERET
 
 __hyp_stub_exit:
@@ -207,9 +208,26 @@ __hyp_stub_exit:
 ENDPROC(__hyp_stub_do_trap)
 
 /*
- * __hyp_set_vectors is only used when ZIMAGE must bounce between HYP
- * and SVC. For the kernel itself, the vectors are set once and for
- * all by the stubs.
+ * __hyp_set_vectors: Call this after boot to set the initial hypervisor
+ * vectors as part of hypervisor installation.  On an SMP system, this should
+ * be called on each CPU.
+ *
+ * r0 must be the physical address of the new vector table (which must lie in
+ * the bottom 4GB of physical address space.
+ *
+ * r0 must be 32-byte aligned.
+ *
+ * Before calling this, you must check that the stub hypervisor is installed
+ * everywhere, by waiting for any secondary CPUs to be brought up and then
+ * checking that BOOT_CPU_MODE_HAVE_HYP(__boot_cpu_mode) is true.
+ *
+ * If not, there is a pre-existing hypervisor, some CPUs failed to boot, or
+ * something else went wrong... in such cases, trying to install a new
+ * hypervisor is unlikely to work as desired.
+ *
+ * When you call into your shiny new hypervisor, sp_hyp will contain junk,
+ * so you will need to set that to something sensible at the new hypervisor's
+ * initialisation entry point.
  */
 ENTRY(__hyp_set_vectors)
 	mov	r1, r0
@@ -225,6 +243,12 @@ ENTRY(__hyp_soft_restart)
 	ret	lr
 ENDPROC(__hyp_soft_restart)
 
+ENTRY(__hyp_reset_vectors)
+	mov	r0, #HVC_RESET_VECTORS
+	__HVC(0)
+	ret	lr
+ENDPROC(__hyp_reset_vectors)
+
 .align 5
 ENTRY(__hyp_stub_vectors)
 __hyp_stub_reset:	W(b)	.
@@ -236,4 +260,5 @@ __hyp_stub_trap:	W(b)	__hyp_stub_do_trap
 __hyp_stub_irq:		W(b)	.
 __hyp_stub_fiq:		W(b)	.
 ENDPROC(__hyp_stub_vectors)
+EXPORT_SYMBOL_GPL(__hyp_stub_vectors)
 
diff --git a/arch/arm64/kernel/hyp-stub.S b/arch/arm64/kernel/hyp-stub.S
index 12c7fad02ae5..efd91abd759e 100644
--- a/arch/arm64/kernel/hyp-stub.S
+++ b/arch/arm64/kernel/hyp-stub.S
@@ -9,6 +9,7 @@
 #include <linux/init.h>
 #include <linux/linkage.h>
 
+#include <asm-generic/export.h>
 #include <asm/assembler.h>
 #include <asm/el2_setup.h>
 #include <asm/kvm_arm.h>
@@ -66,6 +67,7 @@ SYM_CODE_START(__hyp_stub_vectors)
 	ventry	el1_fiq_invalid			// FIQ 32-bit EL1
 	ventry	el1_error_invalid		// Error 32-bit EL1
 SYM_CODE_END(__hyp_stub_vectors)
+EXPORT_SYMBOL_GPL(__hyp_stub_vectors)
 
 	.align 11
 
diff --git a/arch/x86/kernel/apic/apic.c b/arch/x86/kernel/apic/apic.c
index 6d303d1d276c..235ceff4b23d 100644
--- a/arch/x86/kernel/apic/apic.c
+++ b/arch/x86/kernel/apic/apic.c
@@ -199,6 +199,7 @@ static struct resource lapic_resource = {
 };
 
 unsigned int lapic_timer_period = 0;
+EXPORT_SYMBOL_GPL(lapic_timer_period);
 
 static void apic_pm_activate(void);
 
diff --git a/mm/vmalloc.c b/mm/vmalloc.c
index dd6cdb201195..0adbce4ed0c8 100644
--- a/mm/vmalloc.c
+++ b/mm/vmalloc.c
@@ -322,6 +322,7 @@ int ioremap_page_range(unsigned long addr, unsigned long end,
 	flush_cache_vmap(addr, end);
 	return err;
 }
+EXPORT_SYMBOL_GPL(ioremap_page_range);
 
 static void vunmap_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,
 			     pgtbl_mod_mask *mask)
@@ -2082,6 +2083,7 @@ static void *vb_alloc(unsigned long size, gfp_t gfp_mask)
 
 	return vaddr;
 }
+EXPORT_SYMBOL_GPL(__get_vm_area_caller);
 
 static void vb_free(unsigned long addr, unsigned long size)
 {
-- 
2.34.1

